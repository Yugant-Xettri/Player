<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anime Player</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .player-container {
      position: relative;
      width: 100%;
      height: 100%;
      background: #000;
    }

    video {
      width: 100%;
      height: 100%;
      background: #000;
    }

    .player-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 100;
    }

    .player-container:hover .player-overlay,
    .player-container.show-controls .player-overlay {
      opacity: 1;
      pointer-events: auto;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.2);
      border-top-color: #e50914;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));
      padding: 60px 15px 15px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 50;
    }

    .player-container:hover .controls,
    .player-container.show-controls .controls {
      opacity: 1;
    }

    .progress-bar {
      width: 100%;
      height: 5px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      cursor: pointer;
      margin-bottom: 15px;
      position: relative;
    }

    .progress-bar:hover {
      height: 7px;
    }

    .progress-fill {
      height: 100%;
      background: #e50914;
      border-radius: 3px;
      width: 0%;
    }

    .controls-row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .control-btn {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
      white-space: nowrap;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .control-select {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      min-width: 120px;
    }

    .control-select:hover {
      border-color: rgba(255, 255, 255, 0.6);
    }

    .control-select option {
      background: #1a1a1a;
      color: #fff;
    }

    .time-display {
      color: #fff;
      font-size: 12px;
      font-variant-numeric: tabular-nums;
      min-width: 70px;
      text-align: center;
    }

    .spacer {
      flex: 1;
    }

    .error-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #ff6b6b;
      padding: 20px 40px;
      border-radius: 8px;
      text-align: center;
      z-index: 200;
      display: none;
      max-width: 80%;
    }

    .error-message.show {
      display: block;
    }

    .info-panel {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(229, 9, 20, 0.3);
      border-radius: 8px;
      padding: 12px 16px;
      color: #fff;
      font-size: 12px;
      max-width: 300px;
      z-index: 40;
    }

    .info-item {
      margin: 4px 0;
    }

    .info-label {
      color: #e50914;
      font-weight: 600;
    }

    @media (max-width: 768px) {
      .controls {
        padding: 40px 10px 10px;
      }

      .control-btn,
      .control-select {
        padding: 6px 10px;
        font-size: 11px;
      }

      .control-select {
        min-width: 100px;
      }

      .time-display {
        font-size: 11px;
        min-width: 60px;
      }

      .info-panel {
        max-width: 90%;
        font-size: 11px;
      }
    }

    @media (max-width: 480px) {
      .controls {
        padding: 30px 6px 6px;
      }

      .control-btn,
      .control-select {
        padding: 6px 8px;
        font-size: 10px;
      }

      .control-select {
        min-width: 80px;
      }

      .time-display {
        font-size: 10px;
        min-width: 50px;
      }

      .info-panel {
        font-size: 10px;
        padding: 8px 12px;
        top: 10px;
        right: 10px;
      }

      .spacer {
        display: none;
      }

      .controls-row {
        gap: 6px;
      }
    }
  </style>
</head>
<body>
  <div class="player-container">
    <video id="player" crossorigin="anonymous"></video>

    <div class="player-overlay">
      <div class="loading-spinner"></div>
    </div>

    <div class="info-panel">
      <div class="info-item">
        <span class="info-label">Server:</span>
        <span id="current-server">--</span>
      </div>
      <div class="info-item">
        <span class="info-label">Type:</span>
        <span id="current-type">--</span>
      </div>
      <div class="info-item">
        <span class="info-label">Caption:</span>
        <span id="current-caption">--</span>
      </div>
    </div>

    <div class="error-message" id="error-message"></div>

    <div class="controls">
      <div style="margin-bottom: 12px;">
        <div class="progress-bar">
          <div class="progress-fill" id="progress-fill"></div>
        </div>
      </div>

      <div class="controls-row">
        <button class="control-btn" id="play-btn">▶ Play</button>
        
        <select class="control-select" id="server-select">
          <option value="">Loading servers...</option>
        </select>

        <select class="control-select" id="type-select">
          <option value="sub">Subtitled</option>
          <option value="dub">Dubbed</option>
        </select>

        <select class="control-select" id="caption-select">
          <option value="">-- No Captions --</option>
        </select>

        <div class="spacer"></div>

        <div class="time-display">
          <span id="current-time">0:00</span> / <span id="duration">0:00</span>
        </div>

        <select class="control-select" id="quality-select">
          <option value="">Auto (360p)</option>
        </select>
      </div>
    </div>
  </div>

  <script>
    // Get embed parameters from URL
    const urlParams = new URLSearchParams(window.location.search);
    const embedId = window.location.pathname.split('/').pop();
    
    // Parse anime ID and episode from embed ID format: "tvId::ep=episodeId"
    const parseEmbedId = (id) => {
      const parts = id.split('::ep=');
      return {
        tvId: parts[0],
        episodeId: parts[1] || null
      };
    };

    const { tvId, episodeId } = parseEmbedId(embedId);
    
    // State management
    const state = {
      tvId,
      episodeId,
      servers: [],
      currentServer: null,
      currentType: 'sub', // 'sub' or 'dub'
      currentCaption: '',
      currentUrl: null,
      playbackTime: 0,
      hlsInstance: null,
      trackElement: null
    };

    // DOM elements
    const playerEl = document.getElementById('player');
    const playBtn = document.getElementById('play-btn');
    const serverSelect = document.getElementById('server-select');
    const typeSelect = document.getElementById('type-select');
    const captionSelect = document.getElementById('caption-select');
    const qualitySelect = document.getElementById('quality-select');
    const progressBar = document.querySelector('.progress-bar');
    const progressFill = document.getElementById('progress-fill');
    const timeDisplay = document.getElementById('current-time');
    const durationDisplay = document.getElementById('duration');
    const errorMsg = document.getElementById('error-message');
    const playerContainer = document.querySelector('.player-container');

    // LocalStorage key
    const STORAGE_KEY = `anime-player-${tvId}-${episodeId || 'movie'}`;

    // Load saved state from localStorage
    const loadSavedState = () => {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const data = JSON.parse(saved);
        state.playbackTime = data.playbackTime || 0;
        state.currentType = data.currentType || 'sub';
        state.currentServer = data.currentServer || null;
        state.currentCaption = data.currentCaption || '';
      }
    };

    // Save state to localStorage
    const saveState = () => {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        playbackTime: state.playbackTime,
        currentType: state.currentType,
        currentServer: state.currentServer,
        currentCaption: state.currentCaption
      }));
    };

    // Format time display
    const formatTime = (seconds) => {
      if (!isFinite(seconds)) return '0:00';
      const hrs = Math.floor(seconds / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      
      if (hrs > 0) {
        return `${hrs}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
      }
      return `${mins}:${String(secs).padStart(2, '0')}`;
    };

    // Show error message
    const showError = (msg) => {
      errorMsg.textContent = msg;
      errorMsg.classList.add('show');
      setTimeout(() => {
        errorMsg.classList.remove('show');
      }, 5000);
    };

    // Show/hide loading
    const showLoading = (show) => {
      const overlay = document.querySelector('.player-overlay');
      if (show) {
        overlay.style.opacity = '1';
        overlay.style.pointerEvents = 'auto';
      } else {
        overlay.style.opacity = '0';
        overlay.style.pointerEvents = 'none';
      }
    };

    // Fetch stream data from API
    const fetchStreamData = async () => {
      try {
        showLoading(true);
        const url = episodeId 
          ? `/api/stream/tv/${tvId}/ep/${episodeId}`
          : `/api/stream/tv/${tvId}`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to fetch stream data');
        
        const data = await response.json();
        if (!data.success) throw new Error('Invalid stream data');
        
        state.servers = data.servers;
        populateServers();
        
        // Select first server with available content
        const firstServer = state.servers.find(s => s.sources[state.currentType]?.link);
        if (firstServer) {
          state.currentServer = firstServer.id;
          serverSelect.value = firstServer.id;
          await loadStreamSource();
        }
        
        showLoading(false);
      } catch (error) {
        showError(`Error loading streams: ${error.message}`);
        showLoading(false);
      }
    };

    // Populate server dropdown
    const populateServers = () => {
      serverSelect.innerHTML = '';
      state.servers.forEach(server => {
        const hasContent = server.sources.sub?.link || server.sources.dub?.link;
        if (hasContent) {
          const option = document.createElement('option');
          option.value = server.id;
          option.textContent = server.name;
          serverSelect.appendChild(option);
        }
      });
    };

    // Populate captions for current source
    const populateCaptions = () => {
      const server = state.servers.find(s => s.id === state.currentServer);
      if (!server) return;

      const source = server.sources[state.currentType];
      if (!source) {
        captionSelect.innerHTML = '<option value="">-- No Captions --</option>';
        return;
      }

      captionSelect.innerHTML = '<option value="">-- No Captions --</option>';
      
      if (source.captions && typeof source.captions === 'object') {
        Object.entries(source.captions).forEach(([lang, url]) => {
          const option = document.createElement('option');
          option.value = url;
          option.textContent = lang;
          captionSelect.appendChild(option);
        });
      }

      // Restore saved caption
      if (state.currentCaption) {
        captionSelect.value = state.currentCaption;
      }
    };

    // Initialize HLS player
    const initHlsPlayer = (url) => {
      if (state.hlsInstance) {
        state.hlsInstance.destroy();
      }

      if (Hls.isSupported()) {
        state.hlsInstance = new Hls();
        state.hlsInstance.loadSource(url);
        state.hlsInstance.attachMedia(playerEl);
      } else if (playerEl.canPlayType('application/vnd.apple.mpegurl')) {
        playerEl.src = url;
      } else {
        showError('HLS playback not supported');
        return;
      }

      playerEl.volume = 0.8;
    };

    // Load stream source
    const loadStreamSource = async () => {
      try {
        showLoading(true);
        
        const server = state.servers.find(s => s.id === state.currentServer);
        if (!server) throw new Error('Server not found');

        const source = server.sources[state.currentType];
        if (!source?.link) {
          throw new Error(`${state.currentType === 'sub' ? 'Subtitled' : 'Dubbed'} version not available on this server`);
        }

        state.currentUrl = source.link;

        // Initialize player with the stream URL
        initHlsPlayer(source.link);

        // Wait for player to be ready
        await new Promise(resolve => {
          const checkReady = () => {
            if (playerEl.readyState >= 2) {
              resolve();
            } else {
              setTimeout(checkReady, 100);
            }
          };
          checkReady();
        });

        // Set captions if available
        populateCaptions();
        
        if (state.currentCaption && playerEl.textTracks.length === 0) {
          addCaptionTrack(state.currentCaption);
        }

        // Restore playback time
        playerEl.currentTime = state.playbackTime;

        showLoading(false);
        updateInfo();
      } catch (error) {
        showError(`Error loading stream: ${error.message}`);
        showLoading(false);
      }
    };

    // Add external caption track
    const addCaptionTrack = (captionUrl) => {
      // Remove existing external track
      const tracks = Array.from(playerEl.textTracks);
      tracks.forEach(track => {
        if (track.kind === 'captions' && track.label === 'External') {
          const trackEl = Array.from(playerEl.querySelectorAll('track')).find(t => t.label === 'External');
          if (trackEl) trackEl.remove();
        }
      });

      if (!captionUrl) return;

      const track = document.createElement('track');
      track.kind = 'captions';
      track.label = 'External';
      track.src = captionUrl;
      track.default = true;
      playerEl.appendChild(track);
    };

    // Update info panel
    const updateInfo = () => {
      const server = state.servers.find(s => s.id === state.currentServer);
      document.getElementById('current-server').textContent = server?.name || '--';
      document.getElementById('current-type').textContent = state.currentType === 'sub' ? 'Subtitled' : 'Dubbed';
      
      if (state.currentCaption) {
        const option = Array.from(captionSelect.options).find(opt => opt.value === state.currentCaption);
        document.getElementById('current-caption').textContent = option?.textContent || 'Custom';
      } else {
        document.getElementById('current-caption').textContent = 'Off';
      }
    };

    // Event listeners
    playBtn.addEventListener('click', () => {
      if (playerEl.paused) {
        playerEl.play();
        playBtn.textContent = '⏸ Pause';
      } else {
        playerEl.pause();
        playBtn.textContent = '▶ Play';
      }
    });

    playerEl.addEventListener('play', () => {
      playBtn.textContent = '⏸ Pause';
    });

    playerEl.addEventListener('pause', () => {
      playBtn.textContent = '▶ Play';
    });

    playerEl.addEventListener('timeupdate', () => {
      const percent = (playerEl.currentTime / playerEl.duration) * 100;
      progressFill.style.width = percent + '%';
      timeDisplay.textContent = formatTime(playerEl.currentTime);
      state.playbackTime = playerEl.currentTime;
      saveState();
    });

    playerEl.addEventListener('loadedmetadata', () => {
      durationDisplay.textContent = formatTime(playerEl.duration);
    });

    progressBar.addEventListener('click', (e) => {
      const rect = progressBar.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      playerEl.currentTime = percent * playerEl.duration;
      state.playbackTime = playerEl.currentTime;
      saveState();
    });

    serverSelect.addEventListener('change', async (e) => {
      state.currentServer = e.target.value;
      state.playbackTime = playerEl.currentTime;
      saveState();
      await loadStreamSource();
      playerEl.play();
    });

    typeSelect.addEventListener('change', async (e) => {
      state.currentType = e.target.value;
      state.playbackTime = playerEl.currentTime;
      saveState();
      await loadStreamSource();
      playerEl.play();
    });

    captionSelect.addEventListener('change', (e) => {
      state.currentCaption = e.target.value;
      saveState();
      addCaptionTrack(e.target.value);
      updateInfo();
    });

    document.addEventListener('mousemove', () => {
      playerContainer.classList.add('show-controls');
      clearTimeout(playerContainer.hideControlsTimeout);
      playerContainer.hideControlsTimeout = setTimeout(() => {
        if (!playerEl.paused) {
          playerContainer.classList.remove('show-controls');
        }
      }, 3000);
    });

    playerEl.addEventListener('click', () => {
      if (playerEl.paused) {
        playerEl.play();
      } else {
        playerEl.pause();
      }
    });

    // Initialize player
    loadSavedState();
    fetchStreamData();
  </script>
</body>
</html>
